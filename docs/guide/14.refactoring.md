# 14장 리팩토링 가이드
* 가독성, 유지보수성, 성능 등을 개선하기 위해서 리팩토링 실시

## 목차
- [1 폴더 및 파일 구조](#1-폴더-및-파일-구조)
- [2 중복 코드 작성](#2-중복-코드-작성)
- [3 컴포넌트 설계](#3-컴포넌트-설계)
- [4 상태 관리](#4-상태-관리)
- [5 라우팅](#5-라우팅)
- [6 스타일링](#6-스타일링)
- [7 성능 최적화](#7-성능-최적화)
- [8 타입 안정성](#8-타입-안정성)
- [9 코드 일관성](#9-코드-일관성)
- [10 기타](#10-기타)

# 1 폴더 및 파일 구조
## 1.1 개선 대상
* 복잡한 파일 구조, 중복된 컴포넌트가 여러곳에 분산

## 1.2 체크 리스트
* Next.js App Router 구조를 따르는지 (app/, components/, lib/, actions/ 등)
* 파일 이름과 위치가 명확한지 (예: UserProfile.tsx는 components/user 폴더에 위치)
* 공통 컴포넌트가 components 폴더로 잘 분리되었는지
* 서버 액션은 actions/ 폴더, 데이터 조회 함수는 lib/ 폴더에 위치하는지
* page.tsx, layout.tsx 등 Next.js 규약을 따르는지

# 2 중복 코드 작성
## 2.1 개선 대상
* 동일한 로직을 여러 곳에서 반복해서 작성

## 2.2 체크 리스트
* 반복되는 유틸리티 함수나 로직을 별도의 파일(lib/, utils/)로 추출
* 컴포넌트 간 재사용 가능한 부분을 별도 컴포넌트로 분리
* 커스텀 훅으로 클라이언트 로직을 추출 (useAuth, useTheme 등)
* 서버 액션의 공통 로직(에러 처리, 헤더 설정 등)을 추출

# 3 컴포넌트 설계
## 3.1 개선 대상
* 비효율적인 상태 관리, 지나치게 복잡한 컴포넌트

## 3.2 체크 리스트
* 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 분리했는지
  - 데이터 조회는 서버 컴포넌트, 인터랙션은 클라이언트 컴포넌트
* 단일 책임 원칙(SRP)을 지키고 있는지
* Prop Drilling이 심하지 않은지 → Context API, Zustand, Redux 등을 활용
  - https://github.com/FEBC-15/react/tree/main/workspace-ins/ch07-globalstate
* React.memo나 useMemo로 불필요한 리렌더링을 방지했는지
  - https://github.com/FEBC-15/react/tree/main/workspace-ins/ch04-hooks#15-usememo

# 4 상태 관리
## 4.1 개선 대상
* 전역 상태 사용 범위가 불필요하게 넓거나, 로컬 상태로 충분한 데이터를 전역으로 관리

## 4.2 체크 리스트
* 서버 상태와 클라이언트 상태를 구분하여 관리하는지
  - 서버 상태: fetch 캐시, revalidatePath/updateTag로 관리
  - 클라이언트 상태: Zustand, useState로 관리
* 상태가 필요한 컴포넌트에서만 관리하고 있는지
* Zustand 등 전역 상태 관리가 과하게 복잡해지지 않았는지
* 불필요한 전역 상태를 만들지 않았는지 (인증 정보, UI 상태 정도만)

# 5 라우팅
## 5.1 개선 대상
* 경로 관리가 비효율적이거나 중복되는 로직

## 5.2 체크 리스트
* Next.js의 파일 기반 라우팅 구조를 따르는지 (app/[boardType]/page.tsx 등)
* 라우트 그룹 `(user)`을 활용하여 관련 페이지를 그룹화했는지
* 동적 라우트 `[param]`을 적절히 사용하는지
* 로그인 보호가 필요한 페이지는 middleware나 페이지 내 체크 로직이 있는지
* 404, error.tsx를 적절히 배치했는지
* 상태나 필터링 값을 쿼리 파라미터로 사용하는지 (searchParams)

# 6 스타일링
## 6.1 개선 대상
* CSS가 전역적으로 오염되거나 관리가 어렵고, 스타일 중복이 많은 경우

## 6.2 체크 리스트
* CSS-in-JS, Tailwind, SCSS 등 일관된 스타일링 방식을 사용 중인지
* 중복된 스타일을 재사용 가능한 형태로 분리했는지 (예: Button 컴포넌트)
* 글로벌 스타일과 컴포넌트 스타일의 경계를 명확히 했는지

# 7 성능 최적화
## 7.1 개선 대상
* 느린 렌더링, 불필요한 리렌더링, 비효율적인 API 호출

## 7.2 체크 리스트
* fetch 캐시를 적절히 활용하는지 (캐시 태그, revalidatePath, updateTag)
* 서버 컴포넌트를 우선 사용하여 클라이언트 번들 크기를 줄였는지
* 불필요한 상태나 Prop 변경으로 인한 리렌더링 방지 (React.memo, useMemo, useCallback)
* Next.js Image 컴포넌트로 이미지를 최적화했는지
* 동적 import로 필요한 컴포넌트만 로드하는지


# 8 타입 안정성
## 8.1 개선 대상
* 예상치 못한 런타임 오류 방지

## 8.2 체크 리스트
* 모든 컴포넌트와 함수에 명확한 타입을 지정했는지
* API 응답 타입을 types/ 폴더에 정의했는지
* any 타입 사용을 최소화했는지
* 서버 액션의 반환 타입을 명확히 정의했는지

# 9 코드 일관성
## 9.1 개선 대상
* 여러 스타일의 코드가 섞임

## 9.2 체크 리스트
* Prettier, ESLint 등으로 코드 스타일을 통일했는지
* 일관된 네이밍 컨벤션을 따르고 있는지
  - 컴포넌트: PascalCase (UserProfile.tsx)
  - 함수/변수: camelCase (getUserData)
  - 타입/인터페이스: PascalCase (UserInfo)
* 모든 파일에서 동일한 규칙을 따르는지 (import 순서, 함수 작성 방식 등)
* 'use server', 'use client' 지시자를 명확히 표기했는지

# 10 기타

## 10.1 RESTful URL 설계
* Next.js 라우팅 구조를 RESTful하게 설계했는지
  - `/[boardType]`: 게시판 목록
  - `/[boardType]/[_id]`: 게시글 상세
  - `/[boardType]/new`: 게시글 작성
  - `/[boardType]/[_id]/edit`: 게시글 수정

## 10.2 사용자 알림
* alert 대신 toast 라이브러리 사용을 권장
* 또는 Next.js의 useActionState로 폼 상태 메시지 표시

## 10.3 상수 관리

### 10.3.1 코드 관리 API 사용
* [코드 관리 API](https://fesp-api.koyeb.app/market/apidocs/#/코드%20관리) 활용

### 10.3.2 환경 변수 사용
* .env.local 파일에 환경 변수 정의
* 클라이언트에서 접근 필요 시 `NEXT_PUBLIC_` 접두사 사용
* 서버 전용 변수는 접두사 없이 사용

## 10.4 메타데이터
* 각 페이지에 적절한 metadata 설정했는지
* generateMetadata로 동적 메타데이터 생성하는지



