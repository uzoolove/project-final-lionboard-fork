# 13장 자주 묻는 질문

## 목차
- [1 Git](#1-git)
- [2 API 서버](#2-api-서버)
- [3 Next.js](#3-nextjs)
- [4 기타](#4-기타)

# 1 Git

## 1.1 rebase

- 질문: develop 브랜치에서 feature/1-test 브랜치 만들어서 작업하는 중에 develop 브랜치가 업데이트 됨. 작업중이던 feature/1-test 브랜치에 develop 최신 버전을 반영할려면 어떻게 해야 하나요?

- rebase나 merge를 사용해서 develop 브랜치의 최신 내역을 가져올 수 있습니다.

#### Rebase 사용 방법

- git rebase는 Git에서 두 브랜치의 변경 사항을 병합하는 방법 중 하나로, 기존 커밋 기록을 수정하여 히스토리를 깔끔하게 만드는 도구입니다.
- 브랜치의 커밋을 다른 브랜치의 최신 커밋 위에 재배치(rebase)하여, 마치 해당 브랜치에서 작업을 처음부터 했던 것처럼 히스토리가 정리됩니다.

1. develop 브랜치의 최신 내역 가져오기

- git fetch origin

2. feature/1-test 브랜치에서 rebase 실행

- git checkout feature/1-test
- git rebase origin/develop
  - develop 브랜치의 최신 커밋을 기준으로 feature/1-test 브랜치의 커밋을 재배치(rebase)

3. 충돌 해결

- 충돌이 발생하면 충돌을 해결한 후
- git add <파일명> 명령으로 수정된 파일을 추가하고
- rebase를 계속 진행하려면
  - git rebase --continue
- rebase를 중단하고 이전 상태로 돌아가려면
  - git rebase --abort

4. 로컬의 변경 사항을 원격 레포지토리에 푸시

- rebase 이전에 feature 브랜치를 이미 원격 레포지토리에 푸시한 상태라면 rebase한 로컬의 변경 사항을 원격에 푸시해야 함
- git pull origin feature/1-test 명령으로 원격 변경 사항을 가져온 후에(충돌이 발생하면 해결 필요) git push origin feature/1-test 명령으로 다시 푸시
- 또는 원격 변경을 병합하지 않고 덮어쓰고 싶다면 강제로 푸시
  - git push --force origin feature/1-test

#### Merge 사용 방법

1. develop 브랜치의 최신 내역 가져오기

- git fetch origin

2. feature/1-test 브랜치로 이동하여 develop 병합

- git checkout feature/1-test
- git merge origin/develop

3. 충돌 해결

- 충돌이 발생하면 충돌을 해결한 후

- git add 후에 git commit을 사용해 병합 완료

#### Rebase와 Merge의 차이점

##### Rebase

- 기존 커밋 기록을 새롭게 쌓아서, 히스토리가 직선형으로 유지됨
- 충돌이 발생했을 때 커밋별로 하나씩 해결해야 할 수 있음
- 히스토리가 깔끔해 보이지만, 기존 커밋 ID가 변경됨

###### Rebase가 적합한 상황

- 개인 작업 브랜치에서 히스토리를 깔끔하게 유지하고 싶은 경우

##### Merge

- 두 브랜치의 히스토리가 병합되고, merge 커밋이 생성됨
- 히스토리가 병합된다는 점에서 rebase와는 달리 커밋이 분기된 기록이 남음

###### Merge가 적합한 상황

- 협업 중인 브랜치, 이미 원격에 푸시된 브랜치, 히스토리 보존이 중요한 상황

#### 결론

- 개인이 이슈별로 만든 브랜치는 개인 작업 브랜치이므로 rebase가 더 적합해 보임
- 다만 merge는 충돌이 발생하면 한 번만 해결하면 되지만 rebase는 각 커밋을 순차적으로 재배치하므로 여러 커밋에서 충돌이 발생할 경우 각 커밋마다 충돌을 해결해야하므로 충돌 해결이 더 복잡할 수 있음

## 1.2 코드 리뷰시 테스트

- 질문: Github에서 PR 검토할때 코드만 봐서는 잘 알수 없어서 직접 테스트를 해보고 싶은데요?
  - PR 요청한 브랜치를 로컬에 받아와서 테스트를 진행하시면 됩니다.
  ```sh
  # 서버의 변경사항 가져오기
  git fetch
  # PR 브랜치로 체크아웃
  git checkout <PR-브랜치>
  # 새로운 패키지가 추가됐다면
  npm i
  # 개발 서버 구동
  npm run dev
  ```

## 1.3 커밋 메시지 수정

- 질문: 커밋 메시지를 잘못 작성했는데 수정할 수 있나요?
  - 마지막 커밋 메시지를 수정하려면 `git commit --amend`를 사용하세요.
  ```sh
  # 마지막 커밋 메시지 수정
  git commit --amend -m "새로운 커밋 메시지"
  
  # 이미 push한 경우 강제 push 필요
  git push --force origin <브랜치명>
  ```
  - 이미 push한 커밋의 메시지를 수정하면 히스토리가 바뀌므로 개인 브랜치에서만 사용하세요.
  - 여러 개의 커밋 메시지를 수정하려면 `git rebase -i HEAD~N` (N은 수정할 커밋 개수)을 사용하세요.

## 1.4 커밋 취소

- 질문: 잘못된 커밋을 취소하고 싶은데요?
  - 상황에 따라 `git reset` 또는 `git revert`를 사용하세요.

#### git reset 사용
- 로컬에서만 작업하고 아직 push하지 않은 경우
  ```sh
  # 커밋 취소하고 변경사항은 유지 (기본값)
  git reset HEAD~1
  
  # 커밋과 변경사항 모두 취소
  git reset --hard HEAD~1
  
  # 커밋은 취소하고 변경사항은 staging area에 유지
  git reset --soft HEAD~1
  ```

#### git revert 사용
- 이미 push한 커밋을 취소해야 하는 경우
  ```sh
  # 특정 커밋을 되돌리는 새로운 커밋 생성
  git revert <커밋해시>
  
  # 여러 커밋 되돌리기
  git revert <시작커밋해시>..<끝커밋해시>
  ```

## 1.5 특정 파일만 이전 버전으로 되돌리기

- 질문: 전체 커밋이 아닌 특정 파일만 이전 버전으로 되돌리고 싶은데요?
  - `git checkout` 또는 `git restore`를 사용하세요.
  ```sh
  # 특정 커밋의 파일로 되돌리기
  git checkout <커밋해시> -- <파일경로>
  
  # 또는 git restore 사용
  git restore --source=<커밋해시> <파일경로>
  
  # 마지막 커밋의 파일로 되돌리기
  git checkout HEAD -- <파일경로>
  ```

## 1.6 stash 활용

- 질문: 작업 중인 변경사항을 임시로 저장하고 나중에 다시 불러올 수 있나요?
  - `git stash`를 사용하면 됩니다.
  ```sh
  # 현재 변경사항 임시 저장
  git stash
  
  # 메시지와 함께 저장
  git stash save "작업 중인 기능"
  
  # stash 목록 확인
  git stash list
  
  # 가장 최근 stash 적용하고 삭제
  git stash pop
  
  # 가장 최근 stash 적용하고 유지
  git stash apply
  
  # 특정 stash 적용
  git stash apply stash@{0}
  
  # stash 삭제
  git stash drop stash@{0}
  
  # 모든 stash 삭제
  git stash clear
  ```

## 1.7 실수로 커밋한 파일 제거

- 질문: .env 파일을 실수로 커밋했는데 어떻게 제거하나요?
  - 아직 push하지 않았다면 `git reset`을 사용하세요.
  ```sh
  # 마지막 커밋 취소하고 .env를 .gitignore에 추가
  git reset HEAD~1
  echo ".env" >> .gitignore
  git add .
  git commit -m "Remove .env from git"
  ```
  - 이미 push했다면 다음과 같이 히스토리에서 제거하세요.
  ```sh
  # 파일을 git에서만 삭제 (로컬 파일은 유지)
  git rm --cached .env
  echo ".env" >> .gitignore
  git add .gitignore
  git commit -m "Remove .env from repository"
  git push
  ```

## 1.8 브랜치 삭제

- 질문: 작업이 끝난 브랜치를 삭제하려면 어떻게 하나요?
  - 로컬과 원격 브랜치를 각각 삭제할 수 있습니다.
  ```sh
  # 로컬 브랜치 삭제
  git branch -d <브랜치명>
  
  # 병합되지 않은 브랜치 강제 삭제
  git branch -D <브랜치명>
  
  # 원격 브랜치 삭제
  git push origin --delete <브랜치명>
  
  # 로컬의 원격 추적 브랜치 정리
  git fetch --prune
  ```

## 1.9 충돌 해결

- 질문: merge나 rebase 중 충돌이 발생했을 때 어떻게 해결하나요?
  - 충돌이 발생한 파일을 수정한 후 계속 진행하세요.
  ```sh
  # 1. 충돌 파일 확인
  git status
  
  # 2. 충돌 파일 열어서 수정
  # <<<<<<< HEAD
  # 현재 브랜치의 코드
  # =======
  # 병합하려는 브랜치의 코드
  # >>>>>>> feature-branch
  # 위와 같은 마커를 찾아서 적절히 수정
  
  # 3. 수정한 파일 스테이징
  git add <수정한파일>
  
  # 4. 병합 완료 (merge인 경우)
  git commit
  
  # 4. 계속 진행 (rebase인 경우)
  git rebase --continue
  
  # 또는 작업 취소
  git merge --abort  # merge 취소
  git rebase --abort # rebase 취소
  ```

# 2 API 서버

## 2.1 이미지/파일 업로드

- 질문: 이미지를 업로드 하면 서버에 저장되나요?
  - 파일 업로드가 필요한 작업(회원 가입시 프로필 이미지, 상품 등록시 상품 이미지)은 파일 업로드 API를 사용해서 파일을 먼저 업로드하고 받은 path 값을 등록하려는 본문에 추가해서 등록 요청하면 됩니다.
  - dbinit시 첨부 파일은 `dbinit/team/uploadFiles` 폴더에 두어야 합니다.
  - [파일 업로드 API](https://fesp-api.koyeb.app/market/apidocs/#/파일/post_files_) 참고

## 2.2 extra 속성

- 질문: extra 속성은 정해진 이름이 있나요?
  - 제약 없습니다.
  - 기본 속성 이외에 추가할 속성 지정이 필요할 때 사용합니다.
  - 서버는 extra 속성의 값을 상세 조회시 그대로 응답합니다.
  - extra의 특정 속성만 수정하려고 해도 extra 전체가 바뀌기 때문에 전체 값을 다 전달해야 합니다.

## 2.3 북마크/좋아요 기능

- 질문: 좋아요 기능은 API에서 지원 안되나요?
  - 북마크 API에 is_like 필드를 true로 보내면 좋아요 기능으로 사용 가능합니다.
- 질문: 북마크 삭제시 user id가 없는데 어떻게 식별하나요?
  - accessToken에 있으므로 안보내도 됩니다.
- 질문: 북마크 추가/삭제하면 실시간으로 변경 확인할 수 있나요?
  - 가능합니다. 목록 조회나 상세 조회시 내가 북마크한 경우라면 myBookmarkId에 북마크 id가 포함됩니다.
- [북마크/좋아요 추가 API](https://fesp-api.koyeb.app/market/apidocs/#/북마크/post_bookmarks__type_) 참고

## 2.4 게시글 조회

- 질문: private 속성을 true로 등록했을때 다른 user_id로는 게시글을 읽어오는게 불가능한가요?
  - private로 지정하면 작성자만 볼 수 있습니다.
  - 본인이 작성자임을 증명하기 위해 게시글 조회시 accessToken이 필요합니다.

## 2.5 회원 정보

- 질문: 게시글 등록 후 회원정보(이미지, 이름) 수정하면 예전 게시글에는 반영 안되나요?
  - 게시글 등록 당시의 회원정보를 저장하기 때문에 수정 사항이 이전 게시글에는 반영되지 않습니다.
  - 새로운 글에 반영되게 하려면 회원 정보 수정 후 zustand의 상태도 업데이트해야 합니다.

## 2.6 장바구니

- 질문: 장바구니 조회시 응답 받는 cost 속성의 배송비는 자동으로 계산되나요?
  - 네. 셀러가 다르면 배송비가 따로 붙습니다.
- 질문: 상품 상세에서 바로 주문하려면 어떻게 해야 하나요?
  - 브루노 샘플의 [상품 구매(재고 체크)](https://github.com/FEBC-API/APIServer/blob/main/api/bruno/openmarket/02_일반%20회원/02_구매/02_상품%20구매/상품%20구매(재고%20체크).bru) API를 이용하면 장바구니 조회와 같은 포맷으로 응답합니다.
  - 주문페이지에서 쿼리스트링에 id값 유무에 따라 장바구니 조회 or 재고 체크로 분기하면 됩니다.

## 2.7 인증 토큰

- 질문: 클라이언트 컴포넌트에서 accessToken이 안꺼내지나요?
  - 토큰을 스토리지가 아닌 httpOnly 쿠키로 저장했을 경우 js에서는 접근할 수 없습니다.
  - API 통신은 서버 컴포넌트에서 하면 되므로 클라이언트 컴포넌트에서 accessToken을 사용할 일이 없습니다.

## 2.8 주문/결제

- 질문: 상품 구매할때 구매할 상품 정보는 어디까지 보내야 하나요?
  - API 문서처럼 상품id와 수량만 보내면 됩니다.
    - [상품 구매 API](https://fesp-api.koyeb.app/market/apidocs/#/구매/post_orders_) 참고
  - 장바구니 상품을 주문한 거라면 상품 구매 후 장바구니에서 상품 삭제하는 API도 추가로 호출해야 합니다.
    - [장바구니 API](https://fesp-api.koyeb.app/market/apidocs/#/) 참고

## 2.9 dbinit

- 질문: dbinit 이후에 수동으로 추가된 데이터는 재실행시 없어지나요?
  - 네. 초기화가 목적이기 때문에 수동으로 추가된 데이터는 다 사라집니다.
  - 추가된 데이터도 사라지지 않게 하려면 수동으로 추가하지 말고 dbinit/team/data.json에 추가하고 db 초기화를 통해서 데이터를 관리해야 합니다.
- 질문: dbinit 할 때 quantity < buyQuantity 이면 등록이 안되나요?
  - 등록은 되지만 매진된 상품이므로 조회가 안됩니다.
- 질문: data.json 작성시 상품 이미지 속성은 뭐로 하나요?
  - openmarket 샘플을 참고해서 mainImages로 지정하시면 됩니다.

# 3 Next.js

## 3.1 빌드/배포

- 질문: 배포시 `Error: Cannot find module '../lightningcss.linux-x64-gnu.node'` 에러가 발생해요.
  - 프로젝트 루트에서 실행
  ```sh
  # node_modules 폴더 삭제
  rm -rf node_modules

  # package-lock.json 파일 삭제
  rm -f package-lock.json

  # npm 캐시 삭제
  npm cache clean --force

  # 패키지 재설치
  npm install

  # 빌드 재실행
  npm run build
  ```

- 질문: useSearchParams 훅 사용시 빌드 에러가 발생해요
  - 에러: `useSearchParams() should be wrapped in a suspense boundary`
  - 빌드시 SSG 작업때 클라이언트 전용 훅인 useSearchParams()를 사용하면 반드시 CSR로 동작하도록 Suspense로 감싸야 합니다.

## 3.2 서버/클라이언트 컴포넌트

- 질문: 사용자와 상호 작용이 필요한 page는 클라이언트 컴포넌트로 만드나요?
  - page는 서버 컴포넌트를 유지하고 인터렉션 부분은 클라이언트 컴포넌트로 따로 빼서 구현하세요.
- 질문: 주문 목록 조회시 zustand에 저장된 토큰을 가져올 수 없는데요?
  - 쿠키로 토큰을 전달하고 서버함수에서 쿠키에서 꺼내는 방식과 클라이언트 컴포넌트로 만드는 방식 두 가지가 있습니다.

## 3.3 상태 관리

- 질문: 검색어를 입력하면 local storage에 담는데 값이 한박자 늦게 저장돼요.
  - setState()를 호출해도 값이 바로 바뀌지 않고 리렌더링 된 후에 바뀝니다.
  - 추가된 검색어를 변수에 담아두고 변수의 값을 setter와 스토리지의 새로운 값으로 사용하세요.

- 질문: zustand 무한렌더링 에러가 발생해요
  - `useUserStore((state) => {})` 객체를 반환하면 매번 새로 생성되면서 리렌더링이 발생합니다.
  - 속성 하나씩 반환하도록 수정하세요.

# 4 기타

## 4.1 이메일 인증

- 질문: 회원가입시 이메일 인증 어떻게 하나요?
  - 이메일 인증은 가입 중간에 있으면 이탈률이 높아집니다.
  - 이메일 인증은 가입 후에 분리해서 구현하는 것을 권장합니다.
    - [인증 이메일 전송 API](https://fesp-api.koyeb.app/market/apidocs/#/이메일/post_email_verify) 참고
  - 회원 가입 도중에 이메일 인증까지 완료하려면 자체적으로 인증 코드를 생성한 후 [이메일 전송 API](https://fesp-api.koyeb.app/market/apidocs/#/이메일/post_email_)를 요청해서 이메일 본문에 인증 코드를 보내고 사용자가 인증 코드를 입력하면 자체적으로 검증하도록 구현하면 됩니다.

## 4.2 소셜 로그인

- 질문: 카카오/네이버 로그인 어떻게 하나요?
  - [Auth.js](https://authjs.dev/)에서 2024.11월부터 kakao, naver provider를 지원합니다.
  - API 서버를 이용할 필요 없이 Auth.js를 사용하세요.
  - 최종 회원 가입때만 API 서버에 요청하면 됩니다.
    - [OAuth 인증 후 자동 회원 가입](https://fesp-api.koyeb.app/market/apidocs/#/회원/post_users_signup_oauth) 참고

## 4.3 스케쥴러

- 질문: 펀딩 종료시 상태를 바꾸는 스케쥴링이 필요한데요?
  - [스케줄러 API](https://fesp-api.koyeb.app/market/apidocs/#/스케줄러)를 사용하세요.
  - 또는 [Vercel Cron Jobs](https://vercel.com/docs/cron-jobs)를 사용할 수 있습니다.
  - endpoint를 라우트 핸들러로 작성하고 실제 로직을 구현해야 합니다.
  - 펀딩 등록 시 지정한 종료 시간에 펀딩 상태를 바꿀수 있도록 endpoint를 호출하도록 스케쥴러를 등록합니다.
  - 스케쥴러 등록시 endpoint에 쿼리스트링으로 파라미터를 전달하세요.

## 4.4 날씨 API

- 질문: 날씨 API 호출시 CORS 에러가 발생해요
  - 서버 함수나 라우트 핸들러에서 호출하면 CORS 문제가 없습니다.
  - 클라이언트에서 직접 호출하지 마세요.

